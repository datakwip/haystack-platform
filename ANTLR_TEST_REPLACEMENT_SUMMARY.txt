ANTLR Test Replacement Summary
================================

## Changes Made

### 1. Deleted Broken Unit Tests
**Removed**: `api/test/unit/filter/antlr/` (entire directory)

**Files deleted**:
- antlr_service_path_test.py (15 tests)
- antlr_service_name_test.py (7 tests)
- antlr_complex_test.py (2 tests)
- antlr_test_base.py

**Reason**: These tests were broken from the moment they were added to the monorepo:
- They called `get_sql(filter_str, org_id, user_id, db_schema)` (4 parameters)
- But the actual API signature is `get_sql(filter_str, tags, org_id, user_id, db_schema)` (5 parameters)
- The `tags` parameter was added in the original repo before the monorepo merge
- Tests were never updated when the API changed
- They were DOA (dead on arrival) when copied to this monorepo

### 2. Created New Integration Tests
**Added**: `api/test/integration/test_filter.py`

**12 comprehensive tests** covering the `/filter` endpoint:
1. ✅ test_filter_simple_tag - Basic "site" query
2. ✅ test_filter_equip_tag - Find all equipment
3. ✅ test_filter_point_tag - Find all points
4. ✅ test_filter_with_tags_requested - Request specific columns
5. ✅ test_filter_and_operator - Boolean AND (e.g., "equip and ahu")
6. ✅ test_filter_or_operator - Boolean OR (e.g., "ahu or vav")
7. ✅ test_filter_nonexistent_tag - Empty results for missing tags
8. ✅ test_filter_invalid_syntax - 400 error for malformed queries
9. ✅ test_filter_complex_expression - Parentheses and complex logic
10. ✅ test_filter_unauthorized_org - 403 for invalid org access
11. ✅ test_filter_empty_results - Valid query with no matches
12. ✅ test_filter_points_with_specific_type - Combined tag queries

## Test Results

**Before**:
- 28 integration tests passing
- 15 unit tests broken (couldn't run)
- Coverage: 43%

**After**:
- 40 integration tests passing ✅ (+12)
- 0 broken tests
- Coverage: 47% (+4%)

## What the Filter Endpoint Does

The `/filter` endpoint uses ANTLR to parse Haystack filter syntax:

**Request**:
```json
{
  "filter": "equip and ahu",
  "org_id": 1,
  "tags": ["value_s", "value_ref"]
}
```

**Response**:
```json
[
  {
    "entity_id": 123,
    "tags": [
      {"value_s": "AHU-1", "value_ref": 456},
      {"value_s": "Main AHU", "value_ref": null}
    ]
  }
]
```

**Supported Syntax**:
- Simple tags: `site`, `equip`, `point`
- Boolean operators: `and`, `or`, `not`
- Parentheses: `(ahu or vav) and point`
- Path queries: `equipRef->siteRef->yearBuilt`
- Comparisons: `temp > 72`, `yearBuilt == 1985`

## Why Integration Tests Instead of Unit Tests

1. **Real Data**: Tests use simulator-generated building automation data
2. **Full Stack**: Exercises ANTLR parser, SQL generation, database queries, and ACL
3. **Meaningful**: Validates actual user workflows (e.g., "find all temperature points")
4. **Maintainable**: Uses actual API endpoints, not internal functions
5. **Resilient**: Won't break if internal implementation changes

## Running the Tests

```bash
cd /home/csperdue/datakwip-projects/haystack-platform/api
conda activate haystack-platform

# Run all integration tests
pytest test/integration/ -v

# Run just filter tests
pytest test/integration/test_filter.py -v

# Run with coverage
pytest test/integration/ --cov=app --cov-report=html
```

## Next Steps

The filter endpoint now has comprehensive test coverage. Future enhancements could include:
- Tests for path queries (equipRef->siteRef)
- Tests for comparison operators (>, <, ==, !=)
- Tests for edge cases (very long queries, deeply nested parentheses)
- Performance tests for large result sets

These can be added as new test cases to `test_filter.py` as needed.
